;
; Copyright (c) 2012, RISC OS Open Ltd
; Copyright (c) 2012, Adrian Lees
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
; With many thanks to Broadcom Europe Ltd for releasing the source code to
; its Linux drivers, thus making this port possible.
;

; NB. This is currently just a minimal implementation for driving the
;     BCM2835's "mini UART" at 115k2 baud for keyboard/mouse input.
;

        AREA    |Asm$$Code|, CODE, READONLY, PIC

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:Proc

        GET     hdr.BCM2835
        GET     hdr.StaticWS

     [ HALDebug
        IMPORT  output_hex8
        IMPORT  output_newline
        IMPORT  output_text
     ]

        EXPORT  HAL_UARTPorts
        EXPORT  HAL_UARTStartUp
        EXPORT  HAL_UARTShutdown
        EXPORT  HAL_UARTFeatures
        EXPORT  HAL_UARTReceiveByte
        EXPORT  HAL_UARTTransmitByte
        EXPORT  HAL_UARTLineStatus
        EXPORT  HAL_UARTInterruptEnable
        EXPORT  HAL_UARTRate
        EXPORT  HAL_UARTFormat
        EXPORT  HAL_UARTFIFOSize
        EXPORT  HAL_UARTFIFOClear
        EXPORT  HAL_UARTFIFOEnable
        EXPORT  HAL_UARTFIFOThreshold
        EXPORT  HAL_UARTInterruptID
        EXPORT  HAL_UARTBreak
        EXPORT  HAL_UARTModemControl
        EXPORT  HAL_UARTModemStatus
        EXPORT  HAL_UARTDevice

        MACRO
        HALStub $str
     [ HALDebug
        STMFD   sp!,{a1,lr}
        ADR     a1,%FT01
        ADR     lr,%FT02
        B       output_text
01      =       "$str called from "
        ALIGN
02      LDR     a1,[sp,#4]
        BL      output_hex8
        BL      output_newline
        LDMFD   sp!,{a1,lr}
     ]
        MEND


; Put base address into the a1, given port number in a1
        MACRO
$label  BaseAddr
        LDR     a1, PeriBase
        ADD     a1, a1, #UART_Base :AND: :NOT: &FFFF
        ADD     a1, a1, #UART_Base :AND: &FFFF
        MEND

; int HAL_UARTPorts(void)
;
;   Return array of UART port physical addresses.
;
HAL_UARTPorts
;       HALStub "HAL_UARTPorts"
        MOV     a1, #1
        MOV     pc, lr

; void StartUp(int port)
;
HAL_UARTStartUp
        ADD     a3, sb, a1
        DataSyncBarrier a2              ; resync before writing peripheral
        LDR     a2, PeriBase            ; first turn on the serial pins
        ADD     a3, a2, #GPIO_Base      ; (for setting pins up)
        LDR     a2, [a3, #GPFSel1]      ;
        BIC     a2, a2, #8_00770000     ;         
        ORR     a2, a2, #8_00440000     ; set GPIO 14 + 15 to alt0 (100)
        STR     a2, [a3, #GPFSel1]      ;        
        BaseAddr
        DataSyncBarrier a2              ; resync before writing peripheral
        MOV     a2, #0            ;(macro above zeroes the a2)
        STR     a2, [a1,#UARTCR]
        MOV     a2, #&68
        AND     a3, a2,#&3F
        STR     a3, [a1,#UARTFBRD]
        MOV     a2, a2,LSR #6
        STR     a2, [a1,#UARTIBRD]
        MOV     a2, #3<<5
        ORR     a2, a2,#&10
        STR     a2, [a1,#UARTLCRH]
        MOV     a2, #&300
        ORR     a2, a2,#1
        STR     a2, [a1,#UARTCR]
        MOV     pc, lr

; void HAL_UARTShutdown(int port)
;
HAL_UARTShutdown
        BaseAddr
        MOV     a2, #0
        MOV     pc, lr

; int HAL_UARTFeatures(int port)
;
;      Bit 0:  FIFOs available
;      Bit 1:  DMA available
;      Bit 2:  Modem lines available
;
HAL_UARTFeatures
        MOV     a1, #2_101
        MOV     pc, lr

; int HAL_UARTReceiveByte(int port, int *status)
;
;   Returns the next byte from the FIFO (if enabled) or the holding register.
;   If status is non-NULL, the line status associated with the byte is
;   read (see LineStatus). The return value is only meaningful if a
;   received byte is available (bit 0 of *status will be set).
;
HAL_UARTReceiveByte
        STR     lr, [sp, #-4]!
;       HALStub "HAL_UARTReceiveByte"
        BaseAddr
        DataSyncBarrier a3             ; resync after reading peripheral
        LDR     a3, [a1, #UARTFLAG]
        MOV     a4, #1
        BICS    a3, a4, a3, LSR #4
        LDRNE   ip, [a1, #UARTDR]
        TSTNE   ip, #&F00
        STRNE   a2, [a1, #UARTRSRECR]  ;clear error condition
        BNE     rx_error
        TEQ     a2, #0
        STRNE   a3, [a2]
        DataSyncBarrier a3             ; resync after reading peripheral
        AND     a1, ip, #&FF
        LDR     pc, [sp], #4

rx_error
        TEQ     a2,#0
        STRNE   a2,[a2]
        MOV     a1,#0
        LDR     pc,[sp],#4

; void HAL_UARTTransmitByte(int port, int byte)
;
HAL_UARTTransmitByte
        BaseAddr
        DataSyncBarrier a3              ; resync before writing peripheral
        STRB    a2, [a1, #UARTDR]
        MOV     pc, lr

; int HAL_UARTLineStatus(int port)
;
;      Bit 0: Receiver Data Ready
;      Bit 1: Overrun Error
;      Bit 2: Parity Error
;      Bit 3: Framing Error
;      Bit 4: Break Error
;      Bit 5: Transmitter Holding Register Empty
;      Bit 6: Transmitter Empty (including FIFO)
;      Bit 7: FIFO contains a Parity, Framing or Break error
;
;   Parity, Framing and Break errors are associated with each byte received.
;   Whether the values reported here are associated with the last byte
;   read using ReceiveByte or with the next byte to be read is undefined.
;   You should request the status using ReceiveByte to ensure accurate
;   identification of bytes with errors.
;
;   Error bits are cleared whenever status is read, using either LineStatus
;   or ReceiveByte with status non-NULL.
;
HAL_UARTLineStatus
        BaseAddr
        LDR     a2, [a1, #UARTFLAG]
        MOV     a1, #0
        TST     a2, #&80
        ORRNE   a1, a1, #&20
        EORNE   a2, a2, #8
        TSTNE   a2, #8
        ORRNE   a1, a1, #&40
        DataSyncBarrier a2             ; resync after reading peripheral
        MOV     pc, lr

; int HAL_UARTInterruptEnable(int port, int eor, int mask)
;
;   Enables interrupts. Bits are:
;
;      Bit 0: Received Data Available (and Character Timeout)
;      Bit 1: Transmitter Holding Register Empty
;      Bit 2: Received Line Status
;      Bit 3: Modem Status
;
;   Returns previous state.
;
HAL_UARTInterruptEnable
        BaseAddr
        MOV     pc, lr


; int HAL_UARTRate(int port, int baud16)
;
;   Sets the rate, in units of 1/16 of a baud. Returns the previous rate.
;   Use -1 to read.
;
HAL_UARTRate
        BaseAddr
        MOV     pc,lr

; int HAL_UARTFormat(int port, int format)
;
;   Bits 0-1: Bits per word  0=>5, 1=>6, 2=>7, 3=>8
;   Bit 2:    Stop length 0=>1, 1=>2 (1.5 if 5 bits)
;   Bit 3:    Parity enabled
;   Bits 4-5: Parity:  0 => Odd (or disabled)
;                      1 => Even
;                      2 => Mark (parity bit = 1)
;                      3 => Space (parity bit = 0)
;
;   Returns previous format. -1 to read.
;

HAL_UARTFormat
        BaseAddr
        MOV     pc, lr

; void HAL_UARTFIFOSize(int port, int *rx, int *tx)
;
;   Returns the size of the RX and TX FIFOs. Either parameter may be NULL.
;   Note that the size of the TX FIFO is the total amount of data that can
;   be sent immediately when the Transmitter Holding Register Empty
;   status holds. (So an unusual UART that had a transmit threshold
;   should return total FIFO size minus threshold).
;
HAL_UARTFIFOSize
        BaseAddr
        DataSyncBarrier a1              ; resync before writing peripheral
        MOV     a1, #64
        TEQ     a2, #0
        STRNE   a1, [a2]
        TEQ     a3, #0
        STRNE   a1, [a3]
        MOV     pc, lr

; void HAL_UARTFIFOClear(int port, int flags)
;
;   Clears the input FIFO (if bit 0 set) and the output FIFO (if bit 1 set).
;
HAL_UARTFIFOClear
        BaseAddr
        MOV     pc, lr

; int HAL_UARTFIFOEnable(int port, int enable)
;
;   Enables or disables the RX and TX FIFOs: 0 => disable, 1 => enable
;   -1 => read status. Returns previous status.
;
HAL_UARTFIFOEnable
        BaseAddr
        MOV     pc, lr

; int HAL_UARTFIFOThreshold(int port, int threshold)
;
;   Sets the receive threshold level for the FIFO RX interrupt. For OMAP3530
;   this is 8, 16, 56 or 60 bytes. Returns previous value. -1 to read.
;
HAL_UARTFIFOThreshold
        BaseAddr
        MOV     pc, lr

; int HAL_UARTInterruptID(int port)
;
;   Returns the highest priority interrupt currently asserted. In order
;   of priority:
;
;   3 => Receiver Line Status (Cleared by ReceiveByte)
;   2 => Received Data Available (Cleared by reading enough data)
;   6 => Character Timeout (received data waiting)
;   1 => Transmitter Holding Register Empty (Cleared by this call)
;   0 => Modem Status (Cleared by ModemStatus)
;   -1 => No Interrupt
;
;   The Modem Status interrupt occurs when the CTS, DSR or DCD inputs
;   change, or when RI goes from high to low (ie bits 0 to 3 of ModemStatus
;   are set).
;
HAL_UARTInterruptID
        BaseAddr
        MOV     a1, #-1
        MOV     pc, lr

; int HAL_UARTBreak(int port, int enable)
;
;   Activates (1) or deactivates (0) a break condition. -1 to read,
;   returns previous state.
;
HAL_UARTBreak
        BaseAddr
        MOV     pc, lr

; int HAL_UARTModemControl(int port, int eor, int mask)
;
;   Modifies the modem control outputs.
;
;   Bit 0: DTR
;   Bit 1: RTS
;
;   Note that these are logical outputs, although the physical pins may be
;   inverted.  So 1 indicates a request to send.  Returns previous state.
;   Needs to clear the modem interrupt status.
;

HAL_UARTModemControl
        BaseAddr
        MOV     pc, lr


; int HAL_UARTModemStatus(int port)
;
;   Reads the modem status inputs.
;
;   Bit 0: CTS changed since last call
;   Bit 1: DSR changed since last call
;   Bit 2: RI changed from high to low since last call
;   Bit 3: DCD changed since last call
;   Bit 4: CTS
;   Bit 5: DSR
;   Bit 6: RI
;   Bit 7: DCD
;
;   Note that these are logical inputs, although the physical pins may be
;   inverted.  So 1 indicates a Clear To Send condition.  This must also clear
;   the modem interrupt status.
;
HAL_UARTModemStatus
        BaseAddr
        MOV     pc, lr

; int HAL_UARTDevice(int port)
;
;   Return the device number allocated to the UART port
;
HAL_UARTDevice
        MOV     a1, #iDev_GPU_Uart
        MOV     pc, lr

        END
