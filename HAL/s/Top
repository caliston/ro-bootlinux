;
; Copyright (c) 2012, RISC OS Open Ltd
; Copyright (c) 2012, Adrian Lees
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met: 
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of RISC OS Open Ltd nor the names of its contributors
;       may be used to endorse or promote products derived from this software
;       without specific prior written permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
; With many thanks to Broadcom Europe Ltd for releasing the source code to
; its Linux drivers, thus making this port possible.
;

        AREA    |!!!ROMStart|, CODE, READONLY, PIC

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:HALSize.<HALSize>

        GET     Hdr:HALEntries

        GET     hdr.BCM2835
        GET     hdr.StaticWS
        GET     hdr.CastleMacros

        IMPORT  Interrupt_Init
        IMPORT  HAL_IRQEnable
        IMPORT  HAL_IRQDisable
        IMPORT  HAL_IRQClear
        IMPORT  HAL_IRQSource
        IMPORT  HAL_IRQStatus
        IMPORT  HAL_FIQEnable
        IMPORT  HAL_FIQDisable
        IMPORT  HAL_FIQDisableAll
        IMPORT  HAL_FIQClear
        IMPORT  HAL_FIQSource
        IMPORT  HAL_FIQStatus
                
        IMPORT  Timer_Init      
        IMPORT  HAL_Timers
        IMPORT  HAL_TimerDevice
        IMPORT  HAL_TimerGranularity
        IMPORT  HAL_TimerMaxPeriod
        IMPORT  HAL_TimerSetPeriod
        IMPORT  HAL_TimerPeriod
        IMPORT  HAL_TimerReadCountdown
        IMPORT  HAL_TimerIRQClear
                
        IMPORT  HAL_CounterRate
        IMPORT  HAL_CounterPeriod
        IMPORT  HAL_CounterRead
        IMPORT  HAL_CounterDelay
                
        IMPORT  HAL_IICBuses
        IMPORT  HAL_IICType
        IMPORT  HAL_IICDevice
        IMPORT  HAL_IICTransfer
        IMPORT  HAL_IICMonitorTransfer
                
        IMPORT  HAL_NVMemoryType
        IMPORT  HAL_NVMemorySize
        IMPORT  HAL_NVMemoryPageSize
        IMPORT  HAL_NVMemoryProtectedSize
        IMPORT  HAL_NVMemoryProtection
        IMPORT  HAL_NVMemoryRead
        IMPORT  HAL_NVMemoryWrite
                
        IMPORT  HAL_VideoFlybackDevice
        IMPORT  HAL_Video_SetMode
        IMPORT  HAL_Video_WritePaletteEntry
        IMPORT  HAL_Video_WritePaletteEntries
        IMPORT  HAL_Video_ReadPaletteEntry
        IMPORT  HAL_Video_SetInterlace
        IMPORT  HAL_Video_SetBlank
        IMPORT  HAL_Video_SetPowerSave
        IMPORT  HAL_Video_UpdatePointer
        IMPORT  HAL_Video_SetDAG
        IMPORT  HAL_Video_VetMode
        IMPORT  HAL_Video_PixelFormats
        IMPORT  HAL_Video_Features
        IMPORT  HAL_Video_BufferAlignment
        IMPORT  HAL_Video_OutputFormat
        IMPORT  HAL_Video_Render
        IMPORT  HAL_Video_IICOp
                
        IMPORT  HAL_UARTPorts
        IMPORT  HAL_UARTStartUp
        IMPORT  HAL_UARTShutdown
        IMPORT  HAL_UARTFeatures
        IMPORT  HAL_UARTReceiveByte
        IMPORT  HAL_UARTTransmitByte
        IMPORT  HAL_UARTLineStatus
        IMPORT  HAL_UARTInterruptEnable
        IMPORT  HAL_UARTRate
        IMPORT  HAL_UARTFormat
        IMPORT  HAL_UARTFIFOSize
        IMPORT  HAL_UARTFIFOClear
        IMPORT  HAL_UARTFIFOEnable
        IMPORT  HAL_UARTFIFOThreshold
        IMPORT  HAL_UARTInterruptID
        IMPORT  HAL_UARTBreak
        IMPORT  HAL_UARTModemControl
        IMPORT  HAL_UARTModemStatus
        IMPORT  HAL_UARTDevice
                
        IMPORT  HAL_DebugRX
        IMPORT  HAL_DebugTX
                
        IMPORT  HAL_ATAControllerInfo
                
        IMPORT  HAL_KbdScanSetup
        IMPORT  HAL_KbdScan
        IMPORT  HAL_KbdScanFinish
        IMPORT  HAL_KbdScanInterrupt
                
        IMPORT  HAL_USBControllerInfo
        IMPORT  HAL_USBPortPower
        IMPORT  HAL_USBPortStatus
        IMPORT  HAL_USBPortIRQ

        IMPORT  HAL_Video_FramestoreAddress
        
        IMPORT  SDIO_InitDevices

        IMPORT  DMA_InitDevices

        IMPORT  GPIO_InitDevices

        IMPORT  VCHIQ_InitDevices
        
        IMPORT  HAL_SendHostMessage
        IMPORT  HAL_QueryPlatform
        
        EXPORT  HAL_Base
        IMPORT  RamAd
        IMPORT  SerNo
        IMPORT  Displ


HAL_Base
     [ HALDebug
        IMPORT  clear_block
        IMPORT  set_text_colours
        IMPORT  output_char
        IMPORT  output_hex8
        IMPORT  output_newline
        IMPORT  output_regs
        IMPORT  output_text
        IMPORT  output_text_at
        EXPORT  HAL_DebugHexTX4
        EXPORT  HAL_DebugTXStrInline
     ]

        EXPORT  reset
        EXPORT  workspace

        ENTRY

reset   B       start
undef   B       undefined_instr
swi     B       swi_instr
pabort  B       prefetch_abort
dabort  B       data_abort
irq     B       interrupt
fiq     B       fast_interrupt

        ALIGN   256

atags   ; list of 'atags' structures constructed here by the loader code
        ; running on VideoCore, describing
        ; - available memory
        ; - command line parameters, including framebuffer parameters

        ALIGN   4096

end_stack
workspace
        %       sizeof_workspace

        LTORG

        ; exception handlers just for use during HAL init,
        ;   in case something goes wrong

interrupt
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,irq_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,interrupt
        B       output_text_at
     |
        B       interrupt
     ]

fast_interrupt
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,fiq_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,fast_interrupt
        B       output_text_at
     |
        B       fast_interrupt
     ]

swi_instr
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,swi_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,swi_instr
        B       output_text_at
     |
        B       swi_instr
     ]

prefetch_abort
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,pabt_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,prefetch_abort
        B       output_text_at
     |
        B       prefetch_abort
     ]

data_abort
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,dabt_text
        MOV     R1,#0
        MOV     R2,#0
        ADR     R14,data_abort
        B       output_text_at
     |
        B       data_abort
     ]

undefined_instr
        ADRL    sb,workspace
        ADRL    R13,end_stack
     [ HALDebug
        ADR     R0,und_text
        MOV     R1,#0
        MOV     R2,#5
        ADR     R14,undefined_instr
        B       output_text_at
     |
        B       undefined_instr
     ]

     [ HALDebug
fiq_text        =       "FIQ",0
irq_text        =       "IRQ",0
swi_text        =       "SWI",0
pabt_text       =       "Prefetch Abort",0
dabt_text       =       "Data Abort",0
und_text        =       "Undefined Instruction",0
        ALIGN
     ]

start   MSR     CPSR_c,#F32_bit+I32_bit+SVC32_mode

        ADRL    v1, HAL_Base + OSROM_HALSize    ; v1 -> RISC OS image
        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

        ; Ensure CPU is 'set up' (typically enables ICache)
        MOV     a1, #0
        CallOSM OS_InitARM

        ADRL    sb,workspace
        ADRL    R13,end_stack
        ADRL    r4, reset
        STR     r4, MMUOffBaseAddr
        LDR     r4,=IO_Base
        STR     r4,PeriBase

 [ HALDebug
        mov     a1, #1
        bl      HAL_UARTStartUp          ; start early for debug use
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup",10,0
        ALIGN
 ]
        ; Enable USB power
        ; Note - may need changing to enable other devices in future
        ; Looks like we need to write the logical OR of all the devices we want enabled
        MOV     r1, #0
        LDR     r0,=(16:SHL:MB_Pwr_USB)+MB_Chan_Pwr 
        BL      HAL_SendHostMessage

; query the platform and set up a frame buffer.
        BL      HAL_QueryPlatform

;        ADR     R0, mbram
;        ORR     R2, R0, #GPU_L2CnonAl + MB_Chan_FB;  L2 cache on
;        MOV     R0, R2
;        MOV     r1, #0
;;        BL      HAL_SendHostMessage
;         
;        ldr     r3, mbscrsz
;        str     r3, FB_Size
;     mov r0,r3
;     bl HAL_DebugHexTX4
;        ldr     r3, mbbase
;        bic     r3, r3, #GPU_CacheMask
;        str     r3, FB_Base

        LDR     r3, FB_Base
     mov r0,r3
     bl HAL_DebugHexTX4

     [ HALDebug
        STR     R3,ScreenBase     ; for HAL use, remember address we were given
        LDR     r0,mbbpp
        STR     R0,BytesPerChar
        LDR     r3,mbxres
        MUL     r3, r0, r3
        STR     R0,BytesPerRow
        
1002    MOV     R0, R3, LSR #3    
        STR     R0,Columns
        LDR     R0, mbyres
        MOV     R0, r0, lsr #3
        STR     R0,Rows
        MOV     R0,#0
        STR     R0,InvertFont
        STR     R0,OutputX
        STR     R0,OutputY

        LDR     r8, mbbpp
        CMP     r8, #16
        MOVGT   R0,#&FF000000
        MOVGT   R1,#&FF000000
        MVNLE   R0,#0
        MOVLE   R1,#0
        STR     R8,BitsPerPixel
        BL      set_text_colours

        MOV     R0,#0
        MOV     R1,#0
        LDR     R2,Columns
        LDR     R3,Rows
        BL      clear_block

        LDR     r8, mbbpp
        CMP     r8, #16
        MVNGT   R0,#0
        MOVGT   R1,#&FF000000
        MOV     R8,#32
        MOVLE   R0,#&1F<<10
        MOVLE   R1,#0
        BL      set_text_colours

        MOV     R0,#0
        MOV     R1,#0
        ADR     R2,sign_on
        BL      output_text_at
 [ HALDebug
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup2",10,0
        ALIGN
 ]
     ]
ROMTOP   *  6    <<20
        ADRL    a3, workspace
        ADRL    lr,RamAd
        LDR     lr, [lr]
        ADD     a3, a3, lr
        LDMIA   a3, {a1, a2}       ; a1=base, a2=size
 [ HALDebug
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup3 .. rst  rsz",10,0
        ALIGN
        bl      HAL_DebugHexTX4   ; ram start
        mov     a1, a2
        bl      HAL_DebugHexTX4   ; ram end
        LDMIA   a3, {a1, a2}
  ]

; debug hack to force 128meg ram and 6meg rom
;        MOV     v2, #ROMTOP     ;start of available RAM, after HAL + OS image
;        MOV     a1, #RAMTOP     ; end of RAM

        ADD     v2, a1, #ROMTOP   ; start of free ram
        ADD     a1, a2, a1        ; end of RAM
        MOV     a2, #0
        MOV     a3, #0
        MOV     a4, #0
        MOV     v4, #0
        MOV     v5, #0
        MOV     v7, #0
        MOV     ip, #0
        MOV     lr, #0

clear_lp
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        STMDB   a1!,{a2-a4,v4,v5,v7,ip,lr}
        CMP     a1, v2
        BHI     clear_lp
        mov     a2, v2
                                       ; a2 now -> first free ram location
        ADRL    a3, workspace
        ADRL    lr,RamAd
        LDR     lr, [lr]
        ADD     lr, a3, lr
        LDR     a3, [lr, #4]    ; size
        SUB     a3, a3, #ROMTOP ; less what is used
        ADD     a3, a3, a2
 [ HALDebug
        bl      HAL_DebugTXStrInline
        DCB     "HalStartup3 .. rst  rend",10,0
        ALIGN
     mov a1,a2
     bl HAL_DebugHexTX4
     mov a1,a3
     bl HAL_DebugHexTX4
 ]
        MVN     a4, #0
        MOV     a1, #0
        STR     a1, [sp, #-4]!  ;reference handle (NULL for first call)
        CallOSM OS_AddRAM

        STR     a1,[sp] ;ref for next call


  
     [ HALDebug
        ADR     R0,start_os
        BL      output_text
     ]

        ; OS kernel informed of RAM areas

        LDR     a4,[sp],#4      ;!!! ref from last AddRAM
        MOV     a1, #OSStartFlag_RAMCleared
        ADRL    a2, HAL_Base + OSROM_HALSize       ; a2 -> RISC OS image
        ADR     a3, HALdescriptor

        CallOSM OS_Start

        ; OS_Start doesn't return....invokes HAL_Init after MMU activation

     [ HALDebug
sign_on  =      "BCM2835 Raspberry Pi",13,10,0
start_os =      "Starting OS",13,10,0
        ALIGN
     ]

HALdescriptor   DATA
        DCD     HALFlag_NCNBWorkspace
        DCD     HAL_Base - HALdescriptor
        DCD     OSROM_HALSize
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     sizeof_workspace

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource
        HALEntry HAL_IRQStatus
        HALEntry HAL_FIQEnable
        HALEntry HAL_FIQDisable
        HALEntry HAL_FIQDisableAll
        HALEntry HAL_FIQClear
        HALEntry HAL_FIQSource
        HALEntry HAL_FIQStatus

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        HALEntry HAL_NVMemorySize
        HALEntry HAL_NVMemoryPageSize
        HALEntry HAL_NVMemoryProtectedSize
        HALEntry HAL_NVMemoryProtection
        NullEntry ; HAL_NVMemoryIICAddress
        HALEntry HAL_NVMemoryRead
        HALEntry HAL_NVMemoryWrite

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        NullEntry ; HAL_IICSetLines   
        NullEntry ; HAL_IICReadLines  
        HALEntry HAL_IICDevice
        HALEntry HAL_IICTransfer
        HALEntry HAL_IICMonitorTransfer

        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat

        NullEntry ; HALEntry HAL_MatrixColumns
        NullEntry ; HALEntry HAL_MatrixScan

        NullEntry ; HALEntry HAL_TouchscreenType
        NullEntry ; HALEntry HAL_TouchscreenRead
        NullEntry ; HALEntry HAL_TouchscreenMode
        NullEntry ; HALEntry HAL_TouchscreenMeasure

        HALEntry HAL_MachineID

        HALEntry HAL_ControllerAddress
        HALEntry HAL_HardwareInfo
        HALEntry HAL_SuperIOInfo
        HALEntry HAL_PlatformInfo
        NullEntry ; HALEntry HAL_CleanerSpace

        HALEntry HAL_UARTPorts
        HALEntry HAL_UARTStartUp
        HALEntry HAL_UARTShutdown
        HALEntry HAL_UARTFeatures
        HALEntry HAL_UARTReceiveByte
        HALEntry HAL_UARTTransmitByte
        HALEntry HAL_UARTLineStatus
        HALEntry HAL_UARTInterruptEnable
        HALEntry HAL_UARTRate
        HALEntry HAL_UARTFormat
        HALEntry HAL_UARTFIFOSize
        HALEntry HAL_UARTFIFOClear
        HALEntry HAL_UARTFIFOEnable
        HALEntry HAL_UARTFIFOThreshold
        HALEntry HAL_UARTInterruptID
        HALEntry HAL_UARTBreak
        HALEntry HAL_UARTModemControl
        HALEntry HAL_UARTModemStatus
        HALEntry HAL_UARTDevice

        HALEntry HAL_Reset

        HALEntry HAL_DebugRX
        HALEntry HAL_DebugTX

        NullEntry ; HAL_PCIFeatures
        NullEntry ; HAL_PCIReadConfigByte
        NullEntry ; HAL_PCIReadConfigHalfword
        NullEntry ; HAL_PCIReadConfigWord
        NullEntry ; HAL_PCIWriteConfigByte
        NullEntry ; HAL_PCIWriteConfigHalfword
        NullEntry ; HAL_PCIWriteConfigWord
        NullEntry ; HAL_PCISpecialCycle
        NullEntry ; HAL_PCISlotTable
        NullEntry ; HAL_PCIAddresses

        HALEntry HAL_ATAControllerInfo
        NullEntry ; HAL_ATASetModes
        NullEntry ; HAL_ATACableID

        HALEntry HAL_InitDevices

        HALEntry HAL_KbdScanSetup
        HALEntry HAL_KbdScan
        HALEntry HAL_KbdScanFinish
        HALEntry HAL_KbdScanInterrupt

        HALEntry HAL_PhysInfo

        HALEntry HAL_USBControllerInfo

        NullEntry ;HALEntry HAL_MonitorLeadID

        HALEntry HAL_Video_Render

        HALEntry HAL_USBPortPower
        HALEntry HAL_USBPortStatus
        HALEntry HAL_USBPortIRQ

        HALEntry HAL_Video_IICOp

        HALEntry  HAL_TimerIRQClear
        NullEntry ; HAL_TimerIRQStatus

        HALEntry HAL_ExtMachineID

        HALEntry HAL_Video_FramestoreAddress

HAL_Entries     * (.-HAL_EntryTable)/4

;--------------------------------------------------------------------------------------
; HAL Initialisation callback from OS kernel
;--------------------------------------------------------------------------------------

HAL_Init
        STMFD   R13!,{R8,R14}

        MOV     R8,a2
        BL      SetUpOSEntries
        
        MOV     a4, sb                       ; confirm the caching mode in use in GPU
        ADRL    sb, workspace                ; where we remembered it is
        LDR     a3, FB_Size
        LDR     a2, FB_Base                  ; effectively part of the ROM image
        LDR     a1, FB_CacheMode             ; GPU cache mode
        mov     sb, a4
        STR     a3, FB_Size                  ; put in our workspace
        STR     a2, FB_Base                  ; for HAL_FramestoreAddress use
        STR     a1, FB_CacheMode
        ADRL    sb, workspace                ; where we remembered it is
        LDR     a1, mbxres
        LDR     a2, mbyres
        LDR     a3, mbbpp
        mov     sb, a4
        STR     a1, mbxres
        STR     a2, mbyres
        STR     a3, mbbpp

        ; Get the physical address of NCNB workspace
        ; R8 -> start of NCNB workspace
        STR     R8, NCNBAddr

        MOV     a1,R8
        CallOS  OS_LogToPhys
        LDR     a3, FB_CacheMode
        ORR     a1, a1, a3        
        STR     a1, NCNBPhysAddr

        MOV     a1, #0                   ; map in the IO space
        LDR     a2, =IO_Base
        LDR     a3, =IO_Size
        CallOS  OS_MapInIO
        STR     a1, PeriBase

        BL      Interrupt_Init          ; initialise our interrupts
        BL      Timer_Init

        MOV     a1,#0                   ; start the uart ..we use it for debug
        BL      HAL_UARTStartUp         ; restart to capture logical io address

        ; Map in the frame buffer
        ;    and initialise the display driver
        LDR     a3, FB_Size
        LDR     a2, FB_Base                  ; effectively part of the ROM image
     mov r0,a2
     bl HAL_DebugHexTX4
     mov r0,a3
     bl HAL_DebugHexTX4
        MOV     a1, #0
        STR     a1, LastInt
        STR     a1, CurAddr

        CallOS  OS_MapInIO
        STR     a1,ScreenBase
     bl HAL_DebugHexTX4
     
        LDR     a1,mbxres
        LDR     a2,mbbpp   ;=1920*8*4
        STR     a2,BitsPerPixel
        MUL     a1, a2, a1
        STR     a1,BytesPerRow
        STR     a2,BytesPerChar
        LDR     a1,mbxres
        MOV     a1, a1, lsr #3
        STR     a1,Columns
        LDR     a1,mbyres
        MOV     a1, a1, lsr #3
        STR     a1,Rows
        MOV     a1,#0
        STR     a1,InvertFont
        MOV     a1,#4
        STR     a1,OutputX
        STR     a1,OutputY

        CMP     a2, #16
        MOVGT   a1,#-1
        MOVGT   a2,#&FF000000
        MVNLE   a1,#0
        MOVLE   a2,#0
        MOVLE   a1,a1,LSR #17
     [ HALDebug
        BL      set_text_colours

        ADR     a1,hal_init
        BL      output_text
     ]

     [ HALDebug
        ADR     a1,uart_started
        BL      output_text
   
        STR     v1,[sp,#-4]!
        ADRL    v1,hal_init
txloop
txbusylp
        MOV a1,#0
        BL HAL_UARTLineStatus
        TST a1,#&20
        BEQ txbusylp
        MOV a1,#0
        LDRB a2,[v1],#1
        BL HAL_UARTTransmitByte
        LDRB a1,[v1]
        TEQ a1,#0
        BNE txloop
        LDR v1,[sp],#4

        LDMFD   R13!,{R8,PC}

uart_started = " UART started",13,10,0
hal_init     = " HAL Init completed",13,10,0
        ALIGN

     |
        LDMFD   R13!,{R8,PC}
     ]
MBAd  DCD     :INDEX:workspace + :INDEX:mbram


; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADRL    a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0
        MOV     pc, lr

HAL_HardwareInfo
        LDR     ip, =&FFFFFF00
        STR     ip, [a1]
        MOV     ip, #0
        STR     ip, [a2]
        LDR     ip, =&00FFFF00
        STR     ip, [a3]
        MOV     pc, lr

HAL_PlatformInfo
        MOV     ip, #2_10000    ; no podules,no PCI cards,no multi CPU,no soft off,and soft ROM
        STR     ip, [a2]
        MOV     ip, #2_11111    ; mask of valid bits
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

HAL_MachineID
;        ADR     ip, MachAD
        LDR     ip, MachAD
        LDMIA   ip, {a1, a2}
        mov     pc, lr

MachAD  DCD     :INDEX:workspace + :INDEX:MachineID

HAL_ExtMachineID
        MOVS    ip, a1
        MOV     a1, #16
        MOV     pc, lr
        
HAL_Reset
        LDR     a1, PeriBase
        ADD     a1, a1, #PM_Base
        LDR     a2, [a1, #PM_Rstc]
        MOV     a3, #PM_Password
        BIC     a2, a2, #PM_Rst_WCfgSet
        ORR     a2, a2, #PM_Rst_WCfg_FullRst
        ORR     a2, a2, a3
        ADD     a3, a3, #10
        STR     a3, [a1, #PM_Wdog]
        STR     a2, [a1, #PM_Rstc]
        MOV     pc, lr



HAL_PhysInfo
HAL_Null
        MOV     pc, lr

HAL_InitDevices
        STR     lr, [sp, #-4]!
        BL      SDIO_InitDevices
        BL      DMA_InitDevices
        BL      GPIO_InitDevices
        BL      VCHIQ_InitDevices
        LDR     pc, [sp], #4



 [ HALDebug
; a2-> null terminated string
HAL_DebugTXS    ROUT
        STMFD   sp!, {a1,lr}
        SUB     a2,a2,#1
1       LDRB    a1, [a2,#1]!
        TEQ     a1, #&0
        LDMEQFD sp!, {a2,pc}
        BL      HAL_DebugTX
        B       %BT1

HAL_DebugHexTX
       stmfd    r13!, {r0-r3,lr}
       b        jbdt1
HAL_DebugHexTX2
       stmfd    r13!, {r0-r3,lr}
       b        jbdt2
HAL_DebugHexTX4
       stmfd    r13!, {r0-r3,lr}
       mov      r0,r0,ror #24          ; hi byte
       bl       jbdtxh
       mov      r0,r0,ror #24
       bl       jbdtxh
jbdt2
       mov      r0,r0,ror #24
       bl       jbdtxh
       mov      r0,r0,ror #24
jbdt1
       bl       jbdtxh
       mov      r0,#' '
       bl       HAL_DebugTX
       ldmfd    r13!, {r0-r3,pc}

HAL_DebugTXStrInline
       stmfd    r13!, {r0-r3}          ; lr points to prinstring, immediately
                                       ; following call, null terminated
       sub      r3,lr,#1
1      ldrb     r0,[r3,#1]!            ; pop next char, auto incr
       teq      r0,#0                  ; terminating null
       biceq    lr,r3,#3               ; round down address
       ldmeqfd  r13!,{r0-r3}
       addeq    pc,lr,#4               ; return to next word
       bl       HAL_DebugTX            ; else send, then
       b        %bt1                   ; loop

jbdtxh stmfd    r13!,{r0-r3,lr}        ; print byte as hex
       and      a4,a1,#&f              ; get low nibble
       and      a1,a1,#&f0             ; get hi nibble
       mov      a1,a1,lsr #4           ; shift to low nibble
       cmp      a1,#&9                 ; 9?
       addle    a1,a1,#&30
       addgt    a1,a1,#&37             ; convert letter if needed
       bl       HAL_DebugTX
       cmp      a4,#9
       addle    a1,a4,#&30
       addgt    a1,a4,#&37
       bl       HAL_DebugTX
       ldmfd    r13!,{r0-r3,pc}

 |

HAL_DebugTX
HAL_DebugS
HAL_DebugHexTX
HAL_DebugHexTX2
HAL_DebugHexTX4
       MOV     pc, lr
HAL_DebugTXStrInline
       stmfd    r13!, {r0-r3}          ; lr points to prinstring, immediately
                                       ; following call, null terminated
       sub      r3,lr,#1
1      ldrb     r0,[r3,#1]!            ; pop next char, auto incr
       teq      r0,#0                  ; terminating null
       biceq    lr,r3,#3               ; round down address
       ldmeqfd  r13!,{r0-r3}
       addeq    pc,lr,#4               ; return to next word
       b        %bt1                   ; loop

 ]

        END
